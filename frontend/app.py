import os
import requests
import json
from flask import Flask, request, render_template, redirect, url_for, session
from datetime import timedelta
import time # For generating unique IDs and timestamps

# For local development: load environment variables from .env file
# In Azure App Service, these are set as Application Settings
if os.path.exists('.env'):
    from dotenv import load_dotenv
    load_dotenv()

app = Flask(__name__)
app.secret_key = os.environ.get("FLASK_SECRET_KEY", "a_very_secret_key_for_dev") # IMPORTANT: Set a strong secret key in production
app.permanent_session_lifetime = timedelta(minutes=60) # Sessions expire after 60 mins

# Azure Blob Storage Configuration for Frontend Uploads
STORAGE_ACCOUNT_NAME = os.environ.get("STORAGE_ACCOUNT_NAME")
STORAGE_CONTAINER_NAME = "audio-uploads" # Matches the blob trigger in Azure Function
STORAGE_SAS_TOKEN = os.environ.get("STORAGE_SAS_TOKEN") # Will be generated securely by a proxy in production

# Azure Function App URL for transcription status/retrieval
AZURE_FUNCTION_APP_URL = os.environ.get("AZURE_FUNCTION_APP_URL")
AZURE_FUNCTION_GET_TRANSCRIPTION_KEY = os.environ.get("AZURE_FUNCTION_GET_TRANSCRIPTION_KEY") # Function key

@app.route('/')
def index():
    return render_template('index.html', job_id=None, transcription_data=None)

@app.route('/upload', methods=['POST'])
def upload_file():
    if 'audioFile' not in request.files:
        return redirect(request.url)

    file = request.files['audioFile']
    if file.filename == '':
        return redirect(request.url)

    if file:
        file_extension = file.filename.split('.')[-1]
        # Generate a unique filename for the blob to prevent overwrites and ensure uniqueness
        unique_filename = f"{int(time.time())}_{os.urandom(8).hex()}.{file_extension}"

        # In a production scenario, you would NOT expose STORAGE_SAS_TOKEN directly.
        # Instead, your Flask app would call an Azure Function (HTTP trigger)
        # to securely generate a short-lived SAS token for the client to upload.
        # For this tutorial's simplicity, we assume STORAGE_SAS_TOKEN is directly available
        # or that you're using a proxy endpoint.
        # Direct upload to Blob Storage using SAS token (simplified for tutorial)
        # For more secure uploads, use a temporary SAS token generated by a backend API.
        if STORAGE_ACCOUNT_NAME and STORAGE_SAS_TOKEN:
            blob_url = f"https://{STORAGE_ACCOUNT_NAME}.blob.core.windows.net/{STORAGE_CONTAINER_NAME}/{unique_filename}{STORAGE_SAS_TOKEN}"
            headers = {'x-ms-blob-type': 'BlockBlob'}

            try:
                # Flask's file.read() might load the whole file into memory.
                # For very large files, stream it.
                response = requests.put(blob_url, data=file.read(), headers=headers)
                response.raise_for_status() # Raise an exception for bad status codes (4xx or 5xx)

                job_id = unique_filename.split('.')[0] # Use part of the filename as job ID
                session['job_id'] = job_id # Store in session for later retrieval

                return render_template('index.html',
                                       job_id=job_id,
                                       message="File uploaded successfully! Transcription initiated.",
                                       transcription_data=None)
            except requests.exceptions.RequestException as e:
                app.logger.error(f"Error uploading to Blob Storage: {e}")
                return render_template('index.html', error=f"Error uploading file: {e}")
        else:
            return render_template('index.html', error="Storage account not configured.")

    return redirect(url_for('index'))

@app.route('/status')
def get_status():
    job_id = session.get('job_id')

    if not job_id:
        return json.dumps({"status": "no_job"}), 200, {'Content-Type': 'application/json'}

    if not AZURE_FUNCTION_APP_URL or not AZURE_FUNCTION_GET_TRANSCRIPTION_KEY:
        return json.dumps({"status": "error", "message": "Backend configuration missing."}), 500, {'Content-Type': 'application/json'}

    try:
        function_url = f"{AZURE_FUNCTION_APP_URL}/api/getTranscription/{job_id}?code={AZURE_FUNCTION_GET_TRANSCRIPTION_KEY}"
        response = requests.get(function_url)
        response.raise_for_status()
        data = response.json()

        return json.dumps(data), 200, {'Content-Type': 'application/json'}
    except requests.exceptions.RequestException as e:
        app.logger.error(f"Error calling Azure Function for status: {e}")
        return json.dumps({"status": "error", "message": f"Could not retrieve status: {e}"}), 500, {'Content-Type': 'application/json'}

if __name__ == '__main__':
    app.run(debug=True) # Set debug=False in production